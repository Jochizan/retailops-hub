import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';
import { Observable } from 'rxjs';
import { CreateOrderRequest, Order, InventoryItem } from '../models/order.model';
import { StoreService } from './store.service';

/**
 * Service handling all HTTP communication with the RetailOps Backend API.
 * It encapsulates base URL configuration, header generation (including Idempotency Keys),
 * and endpoint definitions.
 */
@Injectable({
  providedIn: 'root'
})
export class ApiService {
  private baseUrl = 'http://localhost:5000/api';
  private storeService = inject(StoreService);

  /**
   * Constructs the HTTP headers required for API requests.
   * Automatically injects the `X-Role` for RBAC simulation and an optional `Idempotency-Key`.
   * @param idempotencyKey (Optional) A UUID string to prevent duplicate operation processing.
   */
  private getHeaders(idempotencyKey?: string): HttpHeaders {
    let headers = new HttpHeaders()
      .set('X-Role', this.storeService.userRole());
    
    if (idempotencyKey) {
      headers = headers.set('Idempotency-Key', idempotencyKey);
    }
    return headers;
  }

  /** Retrieves a list of orders, optionally filtered by store and status. */
  getOrders(storeId?: number, status?: string): Observable<Order[]> {
    let params = new HttpParams();
    if (storeId) params = params.set('storeId', storeId);
    if (status) params = params.set('status', status);

    return this.http.get<Order[]>(`${this.baseUrl}/orders`, { 
      params, 
      headers: this.getHeaders() 
    });
  }

  /**
   * Submits a new order. Generates a client-side UUID for Idempotency.
   * This ensures that if the network fails, retrying the same request won't duplicate the order.
   */
  createOrder(request: CreateOrderRequest): Observable<any> {
    const key = crypto.randomUUID();
    return this.http.post(`${this.baseUrl}/orders`, request, { 
      headers: this.getHeaders(key) 
    });
  }

  /** Confirms a Reserved order, consuming physical stock. */
  confirmOrder(id: number): Observable<any> {
    return this.http.post(`${this.baseUrl}/orders/${id}/confirm`, {}, { 
      headers: this.getHeaders() 
    });
  }

  /** Cancels a Reserved order, releasing reserved stock back to availability. */
  cancelOrder(id: number): Observable<any> {
    return this.http.post(`${this.baseUrl}/orders/${id}/cancel`, {}, { 
      headers: this.getHeaders() 
    });
  }

  /** Gets real-time inventory levels for a specific store. */
  getInventory(storeId: number): Observable<InventoryItem[]> {
    const params = new HttpParams().set('storeId', storeId);
    return this.http.get<InventoryItem[]>(`${this.baseUrl}/inventory`, { 
      params,
      headers: this.getHeaders()
    });
  }

  /** Retrieves the list of configured stores. */
  getStores(): Observable<any[]> {
    return this.http.get<any[]>(`${this.baseUrl}/stores`, { 
      headers: this.getHeaders() 
    });
  }

  // --- Reports Section ---

  /** Fetches SKUs that are below or near their reorder point. */
  getCriticalStock(storeId?: number): Observable<any[]> {
    let params = new HttpParams().set('limit', '5');
    if (storeId) params = params.set('storeId', storeId);
    return this.http.get<any[]>(`${this.baseUrl}/reports/stock-critical`, { 
      params,
      headers: this.getHeaders()
    });
  }

  /** Gets KPIs for sales: total revenue, order count, and growth metrics. */
  getOrdersSummary(storeId?: number): Observable<any> {
    let params = new HttpParams();
    if (storeId) params = params.set('storeId', storeId);
    return this.http.get<any>(`${this.baseUrl}/reports/orders-summary`, { 
      params,
      headers: this.getHeaders()
    });
  }

  /** Gets the top-selling products by quantity. */
  getTopSkus(storeId?: number): Observable<any[]> {
    let params = new HttpParams().set('limit', '5');
    if (storeId) params = params.set('storeId', storeId);
    return this.http.get<any[]>(`${this.baseUrl}/reports/top-skus`, { 
      params,
      headers: this.getHeaders()
    });
  }

  // --- Alerts Section ---

  /** Gets active or resolved stock alerts generated by the Outbox Worker. */
  getAlerts(storeId?: number, status?: string): Observable<any[]> {
    let params = new HttpParams();
    if (storeId) params = params.set('storeId', storeId);
    if (status) params = params.set('status', status);
    return this.http.get<any[]>(`${this.baseUrl}/alerts`, { 
      params,
      headers: this.getHeaders()
    });
  }

  /** Marks an alert as 'Acknowledged' (Under Investigation). */
  ackAlert(id: number): Observable<any> {
    return this.http.post(`${this.baseUrl}/alerts/${id}/ack`, {}, { 
      headers: this.getHeaders() 
    });
  }

  /** Marks an alert as 'Resolved' (Closed). */
  resolveAlert(id: number): Observable<any> {
    return this.http.post(`${this.baseUrl}/alerts/${id}/resolve`, {}, { 
      headers: this.getHeaders() 
    });
  }

  // --- Audit & Diagnostics ---

  /** Retrieves the audit log trail for entities. */
  getAuditLogs(entity?: string): Observable<any[]> {
    let params = new HttpParams();
    if (entity) params = params.set('entity', entity);
    return this.http.get<any[]>(`${this.baseUrl}/audit`, { 
      params,
      headers: this.getHeaders()
    });
  }

  /** Retrieves integration events from the Outbox table. */
  getOutboxEvents(): Observable<any[]> {
    return this.http.get<any[]>(`${this.baseUrl}/outbox`, { 
      headers: this.getHeaders() 
    });
  }

  constructor(private http: HttpClient) { }
}
